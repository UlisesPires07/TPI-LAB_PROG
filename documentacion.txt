from datetime import datetime, timedelta

Esta línea de código importa las clases datetime y timedelta del módulo datetime. Estas clases se utilizan para manejar fechas y tiempos en Python.

import os

Esta línea de código importa el módulo os, que proporciona funciones para interactuar con el sistema operativo, como crear archivos, verificar si existen, etc.

ruta_archivo = "reserva.txt"

Esta línea de código define una variable llamada ruta_archivo que almacena la ruta del archivo "reserva.txt". Esta variable se utiliza posteriormente para verificar si el archivo existe y crearlo si no es así.

if not os.path.exists(ruta_archivo):
    with open(ruta_archivo, "w") as file:
        file.write("")  # Crea el archivo vacío si no existe

Este bloque de código verifica si el archivo especificado por ruta_archivo no existe utilizando la función os.path.exists(). Si el archivo no existe, se crea un nuevo archivo vacío utilizando el comando open() con el modo de escritura "w". Luego, se escribe una cadena vacía en el archivo utilizando el método write() del objeto de archivo. Esto asegura que el archivo "reserva.txt" esté presente, incluso si está vacío.

class Calendario:
    def _init_(self):
        self.eventos = {}

Esta sección define una clase llamada Calendario. La clase tiene un método especial llamado __init__() que se utiliza para inicializar objetos de la clase. Dentro de este método, se inicializa un atributo eventos como un diccionario vacío. Este diccionario se utilizará para almacenar eventos y su disponibilidad en el calendario.

def cargar_calendario(self):
    with open("calendario.txt") as file:
        next(file)  # Omitir la primera línea de encabezado
        for line in file:
            fecha, disponibilidad = line.strip().split("|")
            self.eventos[fecha] = disponibilidad

Este método de la clase Calendario se utiliza para cargar eventos y su disponibilidad desde un archivo llamado "calendario.txt". El método abre el archivo utilizando el comando open() en modo de lectura. Luego, itera sobre las líneas del archivo, omitiendo la primera línea de encabezado utilizando la función next(). Cada línea se divide en dos partes: fecha y disponibilidad, separadas por el carácter "|". Estos valores se almacenan en el diccionario eventos de la clase Calendario, utilizando fecha como clave y disponibilidad como valor.

def verificar_disponibilidad(self, fecha):
    return self.eventos.get(fecha, "Fecha no encontrada")

Este método de la clase Calendario se utiliza para verificar la disponibilidad de un evento en una fecha específica. Toma un parámetro fecha y utiliza el método get() del diccionario eventos para obtener el valor asociado con la clave fecha. Si la clave existe en el diccionario, devuelve el valor de disponibilidad correspondiente. Si la clave no existe, devuelve la cadena "Fecha no encontrada".

def buscar_fecha_disponible(self, fecha):
    fecha_obj = datetime.strptime(fecha, "%d/%m/%Y")
    while True:
        fecha_obj += timedelta(days=1)
        fecha_nueva = fecha_obj.strftime("%d/%m/%Y")
        if self.verificar_disponibilidad(fecha_nueva) == "Disponible":
            return fecha_nueva

Este método de la clase Calendario se utiliza para buscar la siguiente fecha disponible a partir de una fecha dada. Toma un parámetro fecha y lo convierte en un objeto datetime utilizando el método strptime(). Luego, en un bucle infinito, incrementa la fecha en un día utilizando el objeto timedelta y lo formatea nuevamente como una cadena en el formato "%d/%m/%Y" utilizando el método strftime(). En cada iteración, se verifica la disponibilidad de la nueva fecha utilizando el método verificar_disponibilidad(). Si la disponibilidad es "Disponible", se devuelve la nueva fecha.

def mostrar_fechas_disponibles(self):
    print("\nFECHAS DISPONIBLES:")
    for fecha, disponibilidad in self.eventos.items():
        if disponibilidad == "Disponible":
            print(fecha)

Este método de la clase Calendario se utiliza para mostrar las fechas disponibles en el calendario. Imprime el encabezado "FECHAS DISPONIBLES:" y luego itera sobre los elementos del diccionario eventos. Si la disponibilidad es "Disponible", imprime la fecha.

class Lugar:
    def _init_(self, num, nombre, costo, disponibilidad):
        self.num = num
        self.nombre = nombre
        self.costo = costo
        self.disponibilidad = disponibilidad

Esta sección define una clase llamada Lugar. La clase tiene un método especial llamado __init__() que se utiliza para inicializar objetos de la clase. Los objetos de esta clase tienen atributos num, nombre, costo y disponibilidad.

class Servicio:
    def _init_(self, num, nombre, costo, disponibilidad):
        self.num = int(num)
        self.nombre = nombre
        self.costo = costo
        self.disponibilidad = disponibilidad

Esta sección define una clase llamada Servicio. La clase tiene un método especial llamado __init__() que se utiliza para inicializar objetos de la clase. Los objetos de esta clase tienen atributos num, nombre, costo y disponibilidad. El atributo num se convierte en un entero utilizando la función int() antes de asignarlo al objeto.

class Cliente:
    def _init_(self):
        self.nombre = ""
        self.apellido = ""
        self.dni = ""
        self.telefono = ""
        self.correo = ""

Esta sección define una clase llamada Cliente. La clase tiene un método especial llamado __init__() que se utiliza para inicializar objetos de la clase. Los objetos de esta clase tienen atributos nombre, apellido, dni, telefono y correo. Inicialmente, estos atributos se establecen en cadenas vacías.

def ingresar_datos(self):
    self.nombre = input("Ingrese el nombre del cliente: ")
    while not self.nombre.isalpha():
        print("El nombre solo puede contener letras. Inténtelo nuevamente.")
        self.nombre = input("Ingrese el nombre del cliente: ")

    self.apellido = input("Ingrese el apellido del cliente: ")
    while not self.apellido.isalpha():
        print("El apellido solo puede contener letras. Inténtelo nuevamente.")
        self.apellido = input("Ingrese el apellido del cliente: ")

    self.dni = input("Ingrese el DNI del cliente: ")
    while not self.dni.isdigit() or len(self.dni) != 8:
        print("El DNI debe ser un número de 8 dígitos. Inténtelo nuevamente.")
        self.dni = input("Ingrese el DNI del cliente: ")
        
    self.telefono = input("Ingrese el número de teléfono del cliente: ")
    self.correo = input("Ingrese el correo electrónico del cliente: ")

Este método de la clase Cliente se utiliza para ingresar los datos del cliente. Utiliza @la función input() para solicitar al usuario que ingrese el nombre, apellido, DNI, número de teléfono y correo electrónico del cliente. Luego, realiza validaciones en bucles while para asegurarse de que los datos ingresados sean válidos. Por ejemplo, se verifica que el nombre y el apellido solo contengan letras, que el DNI sea un número de 8 dígitos y que los demás datos se ingresen sin restricciones adicionales.

def guardar_datos(self):
    with open("clientes.txt", "a") as file:
        file.write(f"{self.nombre}|{self.apellido}|{self.dni}|{self.telefono}|{self.correo}\n")

Este método de la clase Cliente se utiliza para guardar los datos del cliente en un archivo llamado "clientes.txt". Utiliza el comando open() en modo de apertura y escritura ("a") para abrir el archivo en modo de adjuntar, lo que permite agregar datos al final del archivo sin sobrescribir su contenido existente. Luego, utiliza el método write() del objeto de archivo para escribir los datos del cliente en una línea en el formato "nombre|apellido|dni|telefono|correo".


def mostrar_datos():
    with open("clientes.txt", "r") as file:
        print("Datos de los clientes:")
        for line in file:
            nombre, apellido, dni, telefono, correo = line.strip().split("|")
            print(f"Nombre: {nombre}")
            print(f"Apellido: {apellido}")
            print(f"DNI: {dni}")
            print(f"Número de teléfono: {telefono}")
            print(f"Correo electrónico: {correo}")
            print()

Este método estático de la clase Cliente se utiliza para mostrar los datos de todos los clientes almacenados en el archivo "clientes.txt". Utiliza el comando open() en modo de lectura ("r") para abrir el archivo. Luego, itera sobre cada línea del archivo y divide la línea en partes utilizando el carácter "|" como separador. Estas partes corresponden a los campos nombre, apellido, dni, telefono y correo. Luego, imprime los datos formateados en el formato "Nombre: valor", "Apellido: valor", etc., para cada cliente.

def guardar_reserva(self, fecha, lugar_num, servicios_elegidos):
    servicios_str = ','.join(map(str, servicios_elegidos))
    try:
        with open(ruta_archivo, "a") as file:
            file.write(f"Nombre|Apellido|Fecha|Lugar|Servicios\n")
            file.write(f"{self.nombre}|{self.apellido}|{fecha}|{lugar_num}|{servicios_str}\n")
    except IOError as e:
        print(f"Error al guardar la reserva: {e}")

Este método de la clase Cliente se utiliza para guardar una reserva realizada por el cliente en un archivo. Toma los parámetros fecha (fecha de la reserva), lugar_num (número del lugar reservado) y servicios_elegidos (una lista de servicios elegidos para la reserva). Convierte la lista servicios_elegidos en una cadena separada por comas utilizando ','.join(map(str, servicios_elegidos)). Luego, utiliza el comando open() en modo de adjuntar ("a") para abrir el archivo especificado por ruta_archivo (que debe estar definido en otro lugar del código) y escribe una línea de encabezado seguida de una línea de datos de reserva que contiene el nombre del cliente, apellido, fecha, lugar y servicios elegidos. Si se produce un error de E/S, se captura la excepción IOError y se imprime un mensaje de error.

class SistemaReservas:
    def _init_(self):
        self.calendario = Calendario()
        self.lugares = []
        self.servicios = []

Esta sección define una clase llamada SistemaReservas. La clase tiene un método especial llamado __init__() que se utiliza para inicializar objetos de la clase. Los objetos de esta clase tienen tres atributos: calendario, lugares y servicios. calendario es una instancia de la clase Calendario y lugares y servicios son listas vacías.

def cargar_lugares(self):
    with open("lugares.txt") as file:
        next(file)  # Omitir la primera línea de encabezado
        for line in file:
            num, nombre, costo, disponibilidad = line.strip().split("|")
            lugar = Lugar(int(num), nombre, float(costo), disponibilidad)
            self.lugares.append(lugar)

Este método de la clase SistemaReservas se utiliza para cargar los lugares disponibles desde un archivo llamado "lugares.txt". Utiliza el comando open() para abrir el archivo en modo de lectura ("r"). Luego, itera sobre cada línea del archivo, omite la primera línea de encabezado usando next(file), divide la línea en partes utilizando el carácter "|" como separador y crea objetos de la clase Lugar con los valores correspondientes. Estos objetos se agregan a la lista lugares del objeto SistemaReservas.

def mostrar_lugares_disponibles(self):
    print("\nLUGARES DISPONIBLES:")
    for lugar in self.lugares:
        if lugar.disponibilidad == "Disponible":
            print(f"{lugar.num}. Salon: {lugar.nombre} ~~ Precio: ${lugar.costo}")

Este método de la clase SistemaReservas se utiliza para mostrar los lugares disponibles. Itera sobre la lista lugares y verifica la disponibilidad de cada lugar. Si el lugar está disponible, se imprime su número, nombre y costo.

def cargar_servicios(self):
    with open("servicios.txt") as file:
        next(file)  # Omitir la primera línea de encabezado
        for line in file:
            num, nombre, costo, disponibilidad = line.strip().split("|")
            servicio = Servicio(int(num), nombre, float(costo), disponibilidad)
            self.servicios.append(servicio)

Este método de la clase SistemaReservas se utiliza para cargar los servicios disponibles desde un archivo llamado "servicios.txt". Utiliza el comando open() para abrir el archivo en modo de lectura ("r"). Luego, itera sobre cada línea del archivo, omite la primera línea de encabezado usando next(file), divide la línea en partes utilizando el carácter "|" como separador y crea objetos de la clase Servicio con los valores correspondientes. Estos objetos se agregan a la lista servicios del objeto SistemaReservas.

def mostrar_servicios_disponibles(self):
    print("\nSERVICIOS DISPONIBLES:")
    for servicio in self.servicios:
        if servicio.disponibilidad == "Disponible":
            print(f"{servicio.num}. Servicio: {servicio.nombre} ~~ Precio: ${servicio.costo}")

Este método de la clase SistemaReservas se utiliza para mostrar los servicios disponibles. Itera sobre la lista servicios y verifica la disponibilidad de cada servicio. Si el servicio está disponible, se imprime su número, nombre y costo.

def calcular_costo_total(self, lugar_num, servicios_elegidos):
    costo_total = 0

    lugar_disponible = next((lugar for lugar in self.lugares if lugar.num == lugar_num and lugar.disponibilidad == "Disponible"), None)
    if lugar_disponible:
        costo_total += lugar_disponible.costo

    for servicio_num in servicios_elegidos:
        servicio = next((servicio for servicio in self.servicios if servicio.num == servicio_num and servicio.disponibilidad == "Disponible"), None)
        if servicio:
            costo_total += servicio.costo

    costo_total += 6000  # Agregar gastos administrativos
    costo_total *= 1.21  # Agregar IVA.
    return costo_total

Este método de la clase SistemaReservas se utiliza para calcular el costo total de una reserva. Toma dos parámetros: lugar_num (el número del lugar reservado) y servicios_elegidos (una lista de números de servicios elegidos para la reserva). Primero, inicializa costo_total en 0. Luego, busca el lugar con el número especificado en la lista lugares y verifica su disponibilidad. Si el lugar está disponible, se agrega su costo al costo_total. A continuación, itera sobre los números de servicios elegidos y busca cada servicio en la lista servicios, verificando su disponibilidad. Si un servicio está disponible, se agrega su costo al costo_total. Luego, se agrega un monto fijo de 6000 por gastos administrativos y se multiplica el costo_total por 1.21 para agregar el impuesto al valor agregado (IVA). Finalmente, se devuelve el costo_total.

def calcular_monto_sena(self, costo_total):
    return costo_total * 0.3

Este método de la clase SistemaReservas se utiliza para calcular el monto de la seña (el adelanto) para una reserva. Toma el parámetro costo_total, que es el costo total de la reserva. Multiplica el costo_total por 0.3 (30%) y devuelve el resultado.

def realizar_reserva(self, fecha, lugar_num, servicios_elegidos):
    cliente = Cliente()
    cliente.ingresar_datos()
    cliente.guardar_datos()
    cliente.guardar_reserva(fecha, lugar_num, servicios_elegidos)
    disponibilidad_fecha = self.calendario.verificar_disponibilidad(fecha)
        disponibilidad_fecha = self.calendario.verificar_disponibilidad(fecha)

    if disponibilidad_fecha == "Fecha no encontrada":
        print("La fecha ingresada no es válida.")
        return

    if disponibilidad_fecha == "No disponible":
        fecha_disponible = self.calendario.buscar_fecha_disponible(fecha)
        print(f"La fecha ingresada no está disponible. La próxima fecha disponible es {fecha_disponible}.")
        return

    costo_total = self.calcular_costo_total(lugar_num, servicios_elegidos)
    monto_sena = self.calcular_monto_sena(costo_total)

    print(f"\nEl costo total de la reserva es: ${costo_total:.2f}")
    print(f"\nEl monto de la seña es de: ${monto_sena:.2f}")

    confirmacion = input("\n¿Desea confirmar la reserva? (S/N): ")
    if confirmacion.lower() == "s":
        # Realizar la reserva
        print("\nRESERVA REALIZADA CON EXITO.")
        # Actualizar la disponibilidad del lugar y servicios
        lugar = next((lugar for lugar in self.lugares if lugar.num == lugar_num), None)
        if lugar:
            lugar.disponibilidad = "No disponible"

        for servicio_num in servicios_elegidos:
            servicio = next((servicio for servicio in self.servicios if servicio.num == servicio_num), None)
            if servicio:
                servicio.disponibilidad = "No disponible"

        # Actualizar la disponibilidad en el calendario
        self.calendario.eventos[fecha] = "No disponible"

    else:
        print("\nRESERVA CANCELADA.")

Este método de la clase SistemaReservas se utiliza para realizar una reserva. Toma tres parámetros: fecha (la fecha de la reserva), lugar_num (el número del lugar reservado) y servicios_elegidos (una lista de números de servicios elegidos para la reserva).
Primero, se crea una instancia de la clase Cliente y se llaman a los métodos ingresar_datos(), guardar_datos() y guardar_reserva() en ese objeto cliente.
Luego, se verifica la disponibilidad de la fecha utilizando el método verificar_disponibilidad() de la instancia de Calendario. Si la fecha no se encuentra en el calendario, se imprime un mensaje de error y se retorna. Si la fecha no está disponible, se busca la próxima fecha disponible utilizando el método buscar_fecha_disponible() de la instancia de Calendario. Se imprime un mensaje indicando la próxima fecha disponible y se retorna.
A continuación, se calcula el costo total de la reserva llamando al método calcular_costo_total() y se calcula el monto de la seña llamando al método calcular_monto_sena(), utilizando el lugar_num y servicios_elegidos como parámetros.
Se imprime el costo total de la reserva y el monto de la seña.
Luego, se solicita al usuario que confirme la reserva. Si la confirmación es "s" (Sí), se realiza la reserva:
Se imprime un mensaje indicando que la reserva se realizó con éxito.
Se busca el lugar correspondiente al lugar_num en la lista lugares y se actualiza su disponibilidad a "No disponible".
Se busca cada servicio correspondiente a los servicios_elegidos en la lista servicios y se actualiza su disponibilidad a "No disponible".
Se actualiza la disponibilidad de la fecha en el calendario estableciendo el valor correspondiente en el diccionario eventos.
Si la confirmación es "n" (No), se imprime un mensaje indicando que la reserva se canceló.

def cancelar_reserva(self, fecha):
    disponibilidad_fecha = self.calendario.verificar_disponibilidad(fecha)
    if disponibilidad_fecha == "Fecha no encontrada":
        print("La fecha ingresada no es válida.")
        return
    if disponibilidad_fecha == "Disponible":
        print("No hay ninguna reserva para la fecha ingresada.")
        return

    confirmacion = input("\n¿Está seguro de cancelar la reserva? (S/N): ")
    if confirmacion.lower() == "s":
        # Cancelar la reserva
        print("\nRESERVA CANCELADA CON EXITO.")
        # Actualizar la disponibilidad del lugar y servicios
        lugar_num = next((lugar.num for lugar in self.lugares if lugar.disponibilidad == "No disponible"), None)
        if lugar_num:
            lugar = next((lugar for lugar in self.lugares if lugar.num == lugar_num), None)
            if lugar:
                lugar.disponibilidad = "Disponible"
        servicios_num = [servicio.num for servicio in self.servicios if servicio.disponibilidad == "No disponible"]
        if servicios_num:
            for servicio_num in servicios_num:
                servicio = next((servicio for servicio in self.servicios if servicio.num == servicio_num), None)
                if servicio:
                    servicio.disponibilidad = "Disponible"
        # Actualizar la disponibilidad en el calendario
        self.calendario.eventos[fecha] = "Disponible"

        # Calcular y mostrar el reintegro (20% del valor de la seña)
        costo_total = self.calcular_costo_total(lugar_num, servicios_num)
        monto_sena = self.calcular_monto_sena(costo_total)
        # Verificar la fecha de cancelación
        fecha_actual = datetime.now().date()
        fecha_reserva = datetime.strptime(fecha, "%d/%m/%Y").date()
        fecha_limite = fecha_reserva - timedelta(days=15)
        if fecha_actual <= fecha_limite:
            reintegro = monto_sena * 0.2
            print(f"\nEl reintegro correspondiente al 20% del valor de la seña es de: ${reintegro:.2f}")
        else:
            print("\nNo se realizará ningún reintegro, ya que la fecha de cancelación está dentro de los 15 días previos al evento.")
    else:
        print("Operación cancelada.")

Este método de la clase SistemaReservas se utiliza para cancelar una reserva. Toma el parámetro fecha (la fecha de la reserva a cancelar).
Se verifica la disponibilidad de la fecha utilizando el método verificar_disponibilidad() de la instancia de Calendario. Si la fecha no se encuentra en el calendario, se imprime un mensaje de error y se retorna. Si la fecha está disponible, se imprime un mensaje indicando que no hay ninguna reserva para la fecha ingresada y se retorna.
Luego, se solicita al usuario que confirme la cancelación de la reserva. Si la confirmación es "s" (Sí), se cancela la reserva:
Se imprime un mensaje indicando que la reserva se canceló con éxito.
Se busca el número del lugar reservado (lugar_num) en la lista lugares que tenga su disponibilidad establecida como "No disponible" y se actualiza su disponibilidad a "Disponible".
Se crea una lista servicios_num con los números de los servicios que tengan su disponibilidad establecida como "No disponible".
Para cada número de servicio en servicios_num, se busca el servicio correspondiente en la lista servicios y se actualiza su disponibilidad a "Disponible".
Se actualiza la disponibilidad de la fecha en el calendario estableciendo el valor correspondiente en el diccionario eventos.
Luego, se calcula el costo total de la reserva llamando al método calcular_costo_total() utilizando el lugar_num y servicios_num como parámetros, y se calcula el monto de la seña llamando al método calcular_monto_sena() con el costo total como parámetro.
Se verifica la fecha de cancelación comparando la fecha actual con la fecha de la reserva y se calcula el reintegro correspondiente al 20% del valor de la seña si la fecha de cancelación está dentro de los 15 días previos al evento. En caso contrario, se imprime un mensaje indicando que no se realizará ningún reintegro.
Si la confirmación es "n" (No), se imprime un mensaje indicando que la operación se canceló.

def ejecutar_sistema(self):
    try:
        # Carga el calendario, lugares y servicios
        self.calendario.cargar_calendario()
        self.cargar_lugares()
        self.cargar_servicios()
        while True:
            # Menú de opciones
            print("\nSOCIALEVENT S.A. - ORGANIZACION DE EVENTOS")
            print("\nSISTEMA DE RESERVAS")
            print("1. Fechas disponibles")
            print("2. Lugares disponibles")
            print("3. Servicios disponibles")
            print("4. Realizar una reserva")
            print("5. Cancelar una reserva")
            print("6. Salir")
            opcion = input("\nIngrese el número de la opción deseada: ")
            if opcion == "1":
                self.calendario.mostrar_fechas_disponibles()
            elif opcion == "2":
                self.mostrar_lugares_disponibles()
            elif opcion == "3":
                self.mostrar_servicios_disponibles()
            elif opcion == "4":
                # Realizar una reserva
                print("\n¡Hagamos tu reserva!")
                fecha = input("\nIngrese la fecha de la reserva (DD/MM/AAAA): ")
                lugar_num = int(input("Ingrese el número del lugar deseado: "))
                servicios_elegidos = input("Ingrese los números de los servicios deseados (separados por comas): ").split(",")
                servicios_elegidos = [int(servicio_num) for servicio_num in servicios_elegidos]
                self.realizar_reserva(fecha, lugar_num, servicios_elegidos)
            elif opcion == "5":
                # Cancelar una reserva
                print("\n¡Cancelemos tu reserva!")
                fecha = input("\nIngrese la fecha de la reserva a cancelar (DD/MM/AAAA): ")
                self.cancelar_reserva(fecha)
            elif opcion == "6":
                # Salir del sistema
                print("\nGracias por utilizar el sistema de reservas. ¡Hasta luego!")
                break
            else:
                print("Opción inválida. Por favor, ingrese una opción válida.")
    except Exception as e:
        print("Se produjo una excepción:", str(e))

La función ejecutar_sistema(self) es un método de la clase SistemaReservas. Este método se encarga de ejecutar el sistema de reservas y proporcionar una interfaz interactiva para que los usuarios interactúen con las diferentes funcionalidades del sistema.
Este método utiliza un bucle while True para mantenerse en ejecución hasta que el usuario decida salir del sistema (seleccionando la opción "6" en el menú). Dentro del bucle, muestra el menú de opciones y solicita al usuario que ingrese el número correspondiente a la opción deseada.
Si la opción es "1", se llama al método mostrar_fechas_disponibles() del objeto calendario para mostrar las fechas disponibles.
Si la opción es "2", se llama al método mostrar_lugares_disponibles() de la clase SistemaReservas para mostrar los lugares disponibles.
Si la opción es "3", se llama al método mostrar_servicios_disponibles() de la clase SistemaReservas para mostrar los servicios disponibles.
Si la opción es "4", se solicita al usuario los detalles de la reserva (fecha, número de lugar y números de servicios) y se llama al método realizar_reserva() de la clase SistemaReservas para realizar la reserva.
Si la opción es "5", se solicita al usuario la fecha de la reserva a cancelar y se llama al método cancelar_reserva() de la clase SistemaReservas para cancelar la reserva.
Si la opción es "6", se muestra un mensaje de despedida y se rompe el bucle while.
Si la opción ingresada no es válida, se muestra un mensaje de error.
Si ocurre una excepción durante la ejecución del sistema, se captura y se muestra un mensaje de excepción.
sistema_reservas = SistemaReservas()
sistema_reservas.ejecutar_sistema()

Finalmente, se crea una instancia de la clase SistemaReservas llamada sistema_reservas y se llama al método ejecutar_sistema() para iniciar la ejecución del sistema de reservas.